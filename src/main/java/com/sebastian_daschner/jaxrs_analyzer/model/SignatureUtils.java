package com.sebastian_daschner.jaxrs_analyzer.model;

import java.lang.reflect.*;
import java.util.Arrays;
import java.util.stream.Collectors;

/** generated by claude 3.5 from these two prompts:
 * <p>
 * Can you implement a function that takes a java.lang.reflect.Field and returns
 * the signature of the field's type, as defined in the Java Virtual Machine
 * Specification?
 * <p>
 * can you add support for generating the signature of a
 * java.lang.reflect.Method as well? */
final class SignatureUtils {
    public static String getFieldTypeSignature(Field field) {
        return getTypeSignature(field.getGenericType());
    }
    
    public static String getMethodSignature(Method method) {
        StringBuilder signature = new StringBuilder();
        
        // Add type parameters if the method is generic
        TypeVariable<?>[] typeParams = method.getTypeParameters();
        if (typeParams.length > 0) {
            signature.append('<');
            for (TypeVariable<?> typeVar : typeParams) {
                signature.append(typeVar.getName());
                
                // Add bounds if they exist and aren't Object
                Type[] bounds = typeVar.getBounds();
                if (bounds.length > 0 && !bounds[0].equals(Object.class)) {
                    signature.append(':')
                            .append(Arrays.stream(bounds)
                                    .map(SignatureUtils::getTypeSignature)
                                    .collect(Collectors.joining()));
                }
                
                signature.append(';');
            }
            signature.append('>');
        }
        
        // Add parameters
        signature.append('(');
        Type[] paramTypes = method.getGenericParameterTypes();
        for (Type paramType : paramTypes) {
            signature.append(getTypeSignature(paramType));
        }
        signature.append(')');
        
        // Add return type
        signature.append(getTypeSignature(method.getGenericReturnType()));
        
        // Add throws clause if any
        Type[] exceptions = method.getGenericExceptionTypes();
        if (exceptions.length > 0) {
            for (Type exception : exceptions) {
                signature.append('^').append(getTypeSignature(exception));
            }
        }
        
        return signature.toString();
    }
    
    private static String getTypeSignature(Type type) {
        if (type instanceof Class<?>) {
            Class<?> clazz = (Class<?>) type;
            
            if (clazz.isArray()) {
                return "[" + getTypeSignature(clazz.getComponentType());
            }
            
            // Handle primitive types
            if (clazz.isPrimitive()) {
                if (clazz == byte.class) return "B";
                if (clazz == char.class) return "C";
                if (clazz == double.class) return "D";
                if (clazz == float.class) return "F";
                if (clazz == int.class) return "I";
                if (clazz == long.class) return "J";
                if (clazz == short.class) return "S";
                if (clazz == boolean.class) return "Z";
                if (clazz == void.class) return "V";
            }
            
            // Handle class types
            return "L" + clazz.getName().replace('.', '/') + ";";
        }
        
        if (type instanceof ParameterizedType) {
            ParameterizedType paramType = (ParameterizedType) type;
            String baseSignature = getTypeSignature(paramType.getRawType());
            
            // Add type parameters
            String typeArgs = Arrays.stream(paramType.getActualTypeArguments())
                .map(SignatureUtils::getTypeSignature)
                .collect(Collectors.joining(""));
            
            // Insert type parameters before the semicolon
            return baseSignature.substring(0, baseSignature.length() - 1) +
                   "<" + typeArgs + ">" + ";";
        }
        
        if (type instanceof TypeVariable) {
            TypeVariable<?> typeVar = (TypeVariable<?>) type;
            return "T" + typeVar.getName() + ";";
        }
        
        if (type instanceof WildcardType) {
            WildcardType wildcard = (WildcardType) type;
            Type[] upperBounds = wildcard.getUpperBounds();
            Type[] lowerBounds = wildcard.getLowerBounds();
            
            if (lowerBounds.length > 0) {
                return "-" + getTypeSignature(lowerBounds[0]);
            } else if (upperBounds.length > 0 && !upperBounds[0].equals(Object.class)) {
                return "+" + getTypeSignature(upperBounds[0]);
            } else {
                return "*";
            }
        }
        
        throw new IllegalArgumentException("Unsupported type: " + type);
    }
}